
/*
    Notes:

    For refl (beta) and casts (phi) term rules we have a choice:
        1. Require the forms β{t}. efficient-mendler-codata and recursive-representation-of-data will break with this (but can easily be fixed)
        2. Allow both forms β{t} and β{|t|}, the easiest way to do this is to make the bars optional

    Should we allow optional module headers?
        A lot of the old code allows files to be written that don't have a module definition.
        This could be interpreted as the simplest module definition without too much difficulty.

    Should we require brackets around equality?
        I strongly believe we should require this.
        This effects efficient-mendler, but only in _one_ file, and other files use the brackets

    Should we support abstract (theta) expressions?
        Not supporting them would break some old code (efficient-mendler), they are practically never used otherwise

    Should we support normalize (epsilon) expressions?
        These are used almost excusively for help with rewriting.
        I would argue that this belongs in the tool not inside the syntax

    Should we support μ', σ, or both?
        Both is easy enough, though we should likely prefer σ

    The impred-ind development is probably old enough that it should not be supported, however if we want to:
        1. We need to support line comments with % heading them
        2. We need to support equality without brackets (if we decide to do this, I think we should demand parantheticals)
            Parentheticals would still require altering the existing code, but it wouldn't break the target Cedille
        3. Potentially other problems, there is enough different here that it is hard to figure out everything just by tinkering
*/


main = _{ SOI ~ file ~ EOI }

file = { (import ~ ".")* ~ module_header? ~ decl* }
module_header = { "module" ~ qual_id ~ param* ~ "." }

decl = _{ 
    import ~ "."
    | define_term ~ "."
    | define_type ~ "."
    | define_kind ~ "."
    | define_datatype ~ "."
}

import = { "import" ~ public? ~ path ~ ("as" ~ id)? ~ import_argument* }
define_term = { id ~ ((":" | "◂") ~ type_)? ~ "=" ~ term }
define_type = { id ~ (":" | "◂") ~ kind ~ "=" ~ type_ }
define_kind = { kind_id ~ ("(" ~ id ~ ":" ~ (kind | type_) ~ ")")* ~ "=" ~ kind }
define_datatype = { "data" ~ id ~ param* ~ ":" ~ kind ~ "=" ~ ctors }

term = { term_binder* ~ term_application }

term_application = {
    term_atom
    ~ (erased_op? ~ term_atom | "·" ~ type_atom)*
    ~ (erased_op? ~ term | "·" ~ type_)?
}

term_binder = _{
    term_lambda
    | term_erased_lambda
    | term_let
    | term_erased_let
    | term_rewrite
    | term_annotate
}

term_lambda = { "λ" ~ id ~ (":" ~ type_)? ~ "." }
term_erased_lambda = { "Λ" ~ id ~ (":" ~ (kind | type_))? ~ "." }
term_let = { "[" ~ (define_term | define_type) ~ "]" ~ "-" }
term_erased_let = { "{" ~ (define_term | define_type) ~ "}" ~ "-" }
term_rewrite = { "ρ" ~ reduce? ~ ("<" ~ num ~ ">")? ~ term_atom ~ guide? ~ "-" }
term_annotate = { "χ" ~ type_? ~ "-" }

term_atom = {
    term_intersection ~ proj*
    | term_refl
    | term_cast ~ proj*
    | term_induction ~ proj*
    | term_match ~ proj*
    | term_separate
    | term_symmetry
    | term_abstract
    | "(" ~ term ~ ")" ~ proj*
    | hole
    | qual_id ~ proj*
}

term_intersection = { "[" ~ term ~ "," ~ term ~ "]" }
term_refl = { "β" ~ ("<" ~ term ~ ">")? ~ ("{" ~ "|"? ~ term ~ "|"? ~ "}")? }
term_cast = { "φ" ~ term_atom ~ "-" ~ term_application ~ "{" ~ "|"? ~ term ~ "|"? ~ "}" }
term_induction = { "μ" ~ id ~ "." ~ term_application ~ ("@" ~ type_)? ~ "{" ~ cases ~ "}" }
term_match = { ("μ'" | "σ") ~ ("<" ~ term ~ ">")? ~ term_application ~ ("@" ~ type_)? ~ "{" ~ cases ~ "}" }
term_separate = { "δ" ~ type_? ~ "-" ~ term }
term_symmetry = { "ς" ~ term_atom }
term_abstract = { "θ" ~ (reduce | "<" ~ id+ ~ ">")? ~ term_application }

type_ = { 
    type_binder*
    ~ type_atom
    ~ ((erased_arrow | arrow) ~ type_ | "·" ~ type_atom | term_atom)*
}

type_application = { type_atom ~ ("·" ~ type_atom | term_atom)* }

type_binder = _{
    type_forall
    | type_erased_forall
    | type_lambda
    | type_intersection
    | type_let
}

type_forall = { "Π" ~ id ~ ":" ~ type_ ~ "." }
type_erased_forall = { "∀" ~ id ~ ":" ~ (kind | type_) ~ "." }
type_lambda = { "λ" ~ id ~ ":" ~ (kind | type_) ~ "." }
type_intersection = { "ι" ~ id ~ ":" ~ type_ ~ "." }
type_let = { "[" ~ (define_term | define_type) ~ "]" ~ "-" }

type_atom = {
    "{" ~ term ~ "≃" ~ term ~ "}"
    | "(" ~ type_ ~ ")"
    | hole
    | qual_id
}

kind = { 
    (kind_binder | type_application ~ "➔")*
    ~ kind_atom
    ~ ("➔" ~ kind)*
}

kind_binder = { "Π" ~ id ~ ":" ~ (kind | type_) ~ "." }

kind_atom = { 
    "(" ~ kind ~ ")"
    | "★"
    | qual_kind_id ~ ("·" ~ type_atom | term_atom)+
}

guide = { "@" ~ id ~ ("<" ~ term ~ ">")? ~ "." ~ type_ }

ctors = { "|"? ~ id ~ ":" ~ type_ ~ ("|" ~ id ~ ":" ~ type_)* }
cases = { "|"? ~ case ~ ("|" ~ case)* }
case = { qual_id ~ case_id* ~ "➔" ~ term }
case_id = @{ (type_op | erased_op)? ~ id }

import_argument = { "·" ~ type_ | erased_op? ~ term }
param = { relevant_param | erased_param }
relevant_param = { "(" ~ id ~ ":" ~ (kind | type_) ~ ")" }
erased_param = { "{" ~ id ~ ":" ~ type_ ~ "}" }

id = @{ alpha ~ (alpha | greek | numeral | punctuation)* | "_" }
qual_id = @{ id ~ (("." | "/") ~ id)* }

kind_id = @{ "𝒌" ~ (alpha | numeral | punctuation)* }
qual_kind_id = @{ (id ~ ".")* ~ kind_id }

path = @{ 
    ("../")*
    ~ (alpha | numeral | punctuation | path_delimiter )+
}

path_delimiter = @{
    ("/" | ".") ~ &(alpha | numeral | punctuation)
}

erased_arrow = @{ "➾" }
arrow = @{ "➔" }
erased_op = @{ "-" }
type_op = @{ "·" }
hole = @{ "●" }
proj = @{ ".1" | ".2" }
reduce = @{ "+" }
public = @{ "public" }

alpha = @{ 'a'..'z' | 'A'..'Z' }
greek = @{ 'α'..'ω' | 'Α'..'Ω' }
numeral = @{ '0'..'9' }
punctuation = @{ "_" | "'" | "-" | "!" | "~" }

num = @{ '1'..'9' ~ '0'..'9'* }

multiline_comment = @{ "{-" ~ (!"-}" ~ ANY)* ~ "-}" }
suffix_comment = @{ "{-" ~ ANY* ~ EOI }
line_comment = @{ "--" ~ (!"\n" ~ ANY)* ~ "\n" }

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ line_comment | multiline_comment | suffix_comment }
