
main = _{ SOI ~ file ~ EOI }

file = { (import ~ ".")* ~ "module" ~ qual_id ~ params* ~ "." ~ decl* }

decl = { 
    import ~ "."
    | define_term ~ "."
    | define_type ~ "."
    | define_kind ~ "."
    | define_datatype ~ "."
}

import = { "import" ~ public? ~ path ~ ("as" ~ id)? ~ args* }
define_term = { id ~ (":" ~ type_)? ~ "=" ~ term }
define_type = { id ~ ":" ~ kind ~ "=" ~ type_ }
define_kind = { kind_id ~ ("(" ~ id ~ ":" ~ (kind | type_) ~ ")")* ~ "=" ~ kind }
define_datatype = { "data" ~ id ~ params* ~ ":" ~ kind ~ "=" ~ ctors }

term = { term_binder* ~ term_application }

term_application = {
    term_atom
    ~ (erased_op? ~ term_atom | "·" ~ type_atom)*
    ~ (erased_op? ~ term | "·" ~ type_)?
}

term_binder = _{
    term_lambda
    | term_erased_lambda
    | term_let
    | term_erased_let
    | term_rewrite
    | term_annotate
}

term_lambda = { "λ" ~ id ~ (":" ~ type_)? ~ "." }
term_erased_lambda = { "Λ" ~ id ~ (":" ~ (kind | type_))? ~ "." }
term_let = { "[" ~ (define_term | define_type) ~ "]" ~ "-" }
term_erased_let = { "{" ~ (define_term | define_type) ~ "}" ~ "-" }
term_rewrite = { "ρ" ~ reduce? ~ ("<" ~ num ~ ">")? ~ term_atom ~ guide? ~ "-" }
term_annotate = { "χ" ~ type_? ~ "-" }

term_atom = {
    term_intersection ~ proj?
    | term_refl
    | term_cast ~ proj?
    | term_induction ~ proj?
    | term_match ~ proj?
    | term_separate
    | term_symmetry
    | "(" ~ term ~ ")" ~ proj?
    | hole
    | qual_id ~ proj?
}

term_intersection = { "[" ~ term ~ "," ~ term ~ "]" }
term_refl = { "β" ~ ("<" ~ term ~ ">")? ~ ("{|" ~ term ~ "|}")? }
term_cast = { "φ" ~ term_atom ~ "-" ~ term_atom ~ "{|" ~ term ~ "|}" }
term_induction = { "μ" ~ id ~ "." ~ term_application ~ ("@" ~ type_)? ~ "{" ~ cases ~ "}" }
term_match = { "σ" ~ ("<" ~ term ~ ">")? ~ term_application ~ ("@" ~ type_)? ~ "{" ~ cases ~ "}" }
term_separate = { "δ" ~ type_? ~ "-" ~ term_application }
term_symmetry = { "ς" ~ term_atom }

type_ = { 
    type_binder*
    ~ type_atom
    ~ ((erased_arrow | arrow) ~ type_ | "·" ~ type_atom | term_atom)*
}

type_application = { type_atom ~ ("·" ~ type_atom | term_atom)* }

type_binder = {
    type_forall
    | type_erased_forall
    | type_lambda
    | type_intersection
    | type_let
}

type_forall = { "Π" ~ id ~ ":" ~ type_ ~ "." }
type_erased_forall = { "∀" ~ id ~ ":" ~ (kind | type_) ~ "." }
type_lambda = { "λ" ~ id ~ ":" ~ (kind | type_) ~ "." }
type_intersection = { "ι" ~ id ~ ":" ~ type_ ~ "." }
type_let = { "[" ~ (define_term | define_type) ~ "]" ~ "-" }

type_atom = {
    "{" ~ term ~ "≃" ~ term ~ "}"
    | "(" ~ type_ ~ ")"
    | hole
    | qual_id
}

kind = { 
    (kind_binder | type_application ~ "➔")*
    ~ kind_atom
    ~ ("➔" ~ kind)*
}

kind_binder = { "Π" ~ id ~ ":" ~ (kind | type_) ~ "." }

kind_atom = { 
    "(" ~ kind ~ ")"
    | "★"
    | qual_kind_id ~ ("·" ~ type_atom | term_atom)+
}

ctors = { "|"? ~ id ~ ":" ~ type_ ~ ("|" ~ id ~ ":" ~ type_)* }
cases = { "|"? ~ case ~ ("|" ~ case)* }
case = { qual_id ~ args* ~ "➔" ~ term }

guide = { "@" ~ id ~ term? ~ "." ~ type_ }
args = { term | "-" ~ term | "·" ~ type_ }
params = { 
    "(" ~ id ~ ":" ~ (kind | type_) ~ ")"
    | "{" ~ id ~ ":" ~ type_ ~ "}"
}

id = @{ alpha ~ (alpha | greek | numeral | punctuation)* | "_" }
qual_id = @{ id ~ (("." | "/") ~ id)* }

kind_id = @{ "𝒌" ~ (alpha | numeral | punctuation)* }
qual_kind_id = @{ (id ~ ".")* ~ kind_id }

path = @{ 
    ("../")*
    ~ (alpha | numeral | punctuation | path_delimiter )+
}

path_delimiter = @{
    ("/" | ".") ~ &(alpha | numeral | punctuation)
}

erased_arrow = @{ "➾" }
arrow = @{ "➔" }
erased_op = @{ "-" }
hole = @{ "●" }
proj = @{ ".1" | ".2" }
reduce = @{ "+" }
public = @{ "public" }

alpha = @{ 'a'..'z' | 'A'..'Z' }
greek = @{ 'α'..'ω' | 'Α'..'Ω' }
numeral = @{ '0'..'9' }
punctuation = @{ "_" | "'" | "-" | "!" }

num = @{ '1'..'9' ~ '0'..'9'* }

multiline_comment = @{ "{-" ~ (!"-}" ~ ANY)* ~ "-}" }
line_comment = @{ "--" ~ (!"\n" ~ ANY)* ~ "\n" }

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ line_comment | multiline_comment }
