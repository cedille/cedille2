
main = _{ SOI ~ file ~ EOI }

file = _{ (import ~ ".")* ~ module_header ~ decl* }
module_header = { "module" ~ path ~ param* ~ "." }

decl = _{ 
    import ~ "."
    | define_term ~ "."
    | define_type ~ "."
    | define_kind ~ "."
    | define_datatype ~ "."
    | normalize_command ~ "."
}

import = { "import" ~ public? ~ path ~ ("as" ~ id)? ~ import_argument* }
define_term = { bound_id ~ ((":" | "â—‚") ~ type_)? ~ "=" ~ term }
define_type = { bound_id ~ ((":" | "â—‚") ~ kind)? ~ "=" ~ type_ }
define_kind = { kind_id ~ kind_arg* ~ "=" ~ kind }
define_datatype = { "data" ~ id ~ param* ~ ":" ~ kind ~ "=" ~ ctors }
normalize_command = { "#normalize" ~ term_atom }

term = { term_binder* ~ term_application }

term_application = {
    term_atom
    ~ (erased_op? ~ term_atom | "Â·" ~ type_atom)*
    ~ (erased_op? ~ term | "Â·" ~ type_)?
}

term_binder = _{
    term_lambda
    | term_erased_lambda
    | term_let
    | term_erased_let
    | term_rewrite
    | term_annotate
}

term_lambda_single_var = { bound_id ~ (":" ~ type_)? }
term_lambda_relevant_var = { bound_id ~ !":" | ("(" ~ bound_id ~ (":" ~ type_)? ~ ")") }
term_lambda_erased_var = { "-" ~ (bound_id | ("(" ~ bound_id ~ (":" ~ (kind | type_))? ~ ")")) }
term_lambda = { "Î»" ~ ((term_lambda_relevant_var | term_lambda_erased_var)+ | term_lambda_single_var) ~ "." }
term_erased_lambda = { "Î›" ~ bound_id ~ (":" ~ (kind | type_))? ~ "." }
term_let = { "[" ~ (define_term | define_type) ~ "]" ~ "-" }
term_erased_let = { "{" ~ define_term ~ "}" ~ "-" }
term_rewrite = { "Ï" ~ reduce? ~ ("<" ~ num ~ ">")? ~ term_atom ~ guide? ~ "-" }
term_annotate = { "Ï‡" ~ type_ ~ "-" }

term_atom = {
    term_intersection ~ proj*
    | term_refl
    | term_cast ~ proj*
    | term_induction ~ proj*
    | term_match ~ proj*
    | term_separate
    | term_symmetry
    | "(" ~ term ~ ")" ~ proj*
    | hole
    | omission
    | qual_id ~ proj*
}

term_intersection = { "[" ~ term ~ "," ~ term ~ "]" }
term_refl = { "Î²" ~ term_guide? ~ ("{" ~ term ~ "}")? }
term_cast = { "Ï†" ~ term_atom ~ "-" ~ term_application ~ "{" ~ term ~ "}" }
term_induction = { "Î¼" ~ id ~ "." ~ term_application ~ ("@" ~ type_)? ~ "{" ~ cases ~ "}" }
term_match = { ("Ïƒ" | mu_prime) ~ term_guide? ~ term_application ~ ("@" ~ type_)? ~ "{" ~ cases ~ "}" }
term_separate = { "Î´" ~ type_? ~ "-" ~ term }
term_symmetry = { "Ï‚" ~ term_atom }

type_ = { type_binder* ~ type_body }

type_body = { 
    type_atom
    ~ ((erased_arrow | arrow) ~ type_ | "Â·" ~ type_atom | term_atom)*
}

type_application = { type_atom ~ ("Â·" ~ type_atom | term_atom)* }

type_binder = _{
    type_forall
    | type_erased_forall
    | type_lambda
    | type_intersection
    | type_let
}

type_lambda_single_var = { bound_id ~ (":" ~ (kind | type_))? }
type_lambda_var = { bound_id ~ !":" | ("(" ~ bound_id ~ (":" ~ (kind | type_))? ~ ")") }
type_lambda = { "Î»" ~ ((type_lambda_var+) | type_lambda_single_var) ~ "." }
type_forall = { "Î " ~ bound_id ~ ":" ~ type_ ~ "." }
type_erased_forall = { "âˆ€" ~ bound_id ~ ":" ~ (kind | type_) ~ "." }
type_intersection = { "Î¹" ~ bound_id ~ ":" ~ type_ ~ "." }
type_let = { "[" ~ (define_term | define_type) ~ "]" ~ "-" }

type_atom = {
    "{" ~ term ~ "â‰ƒ" ~ term ~ "}"
    | "(" ~ type_ ~ ")"
    | hole
    | omission
    | qual_id
}


kind = { 
    (kind_binder | type_application ~ "â”")*
    ~ kind_atom
    ~ ("â”" ~ kind)*
}

kind_binder = { "Î " ~ bound_id ~ ":" ~ (kind | type_) ~ "." }

kind_atom = { 
    "(" ~ kind ~ ")"
    | star
    | qual_kind_id ~ ("Â·" ~ type_atom | term_atom)+
}

kind_arg = { "(" ~ id ~ ":" ~ (kind | type_) ~ ")" }

guide = { "@" ~ id ~ term_guide? ~ "." ~ type_ }

ctors = { "|"? ~ ctor ~ ("|" ~ ctor)* }
ctor = { id ~ ":" ~ type_ }
cases = { "|"? ~ case ~ ("|" ~ case)* }
case = { qual_id ~ case_arg* ~ "â”" ~ term }
case_arg = ${ (type_op | erased_op)? ~ id }

import_argument = { "Â·" ~ type_ | erased_op? ~ term }
param = { relevant_param | erased_param }
relevant_param = { "(" ~ id ~ ":" ~ (kind | type_) ~ ")" }
erased_param = { "{" ~ id ~ ":" ~ type_ ~ "}" }

term_guide = { "<" ~ term ~ ">" }

bound_id = { id | omission }
id = @{ alpha ~ (alpha | greek | numeral | punctuation)* | "_" }
qual_id = ${ (id ~ ("."|"/") ~ &id)* ~ id  }

kind_id = @{ "ğ’Œ" ~ (alpha | numeral | punctuation)* }
qual_kind_id = ${ (id ~ "." ~ &id)* ~ kind_id }

path = @{
    ("../")* ~ (alpha | numeral | punctuation | "/" )+
}

erased_arrow = @{ "â¾" }
arrow = @{ "â”" }
erased_op = @{ "-" }
type_op = @{ "Â·" }
hole = @{ "â—" }
omission = @{ "_" }
star = @{ "â˜…" }
proj = @{ ".1" | ".2" }
reduce = @{ "+" }
public = @{ "public" }
mu_prime = @{ "Î¼'" }

alpha = @{ 'a'..'z' | 'A'..'Z' }
greek = @{ 'Î±'..'Ï‰' | 'Î‘'..'Î©' }
numeral = @{ '0'..'9' }
punctuation = @{ "_" | "'" | "-" | "!" | "~" }

num = @{ '1'..'9' ~ '0'..'9'* }

multiline_comment = @{ "{-" ~ (!"-}" ~ ANY)* ~ "-}" }
suffix_comment = @{ "{-" ~ ANY* ~ EOI }
line_comment = @{ "--" ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI) }

WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT = _{ line_comment | multiline_comment | suffix_comment }
