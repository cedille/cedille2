
main = _{ SOI ~ file ~ EOI }

file = _{ (import ~ ".")* ~ module_header ~ decl* }
module_header = { "module" ~ path ~ param* ~ "." }

decl = _{ 
    import ~ "."
    | define_term ~ "."
    | define_type ~ "."
    | define_kind ~ "."
    | define_datatype ~ "."
    | normalize_command ~ "."
}

import = { "import" ~ public? ~ path ~ ("as" ~ id)? ~ import_argument* }
define_term = { bound_id ~ ((":" | "◂") ~ type_)? ~ "=" ~ term }
define_type = { bound_id ~ ((":" | "◂") ~ kind)? ~ "=" ~ type_ }
define_kind = { kind_id ~ kind_arg* ~ "=" ~ kind }
define_datatype = { "data" ~ id ~ param* ~ ":" ~ kind ~ "=" ~ ctors }
normalize_command = { "#normalize" ~ term_atom }

term = { term_binder* ~ term_application }

term_application = {
    term_atom
    ~ (erased_op? ~ term_atom | "·" ~ type_atom)*
    ~ (erased_op? ~ term | "·" ~ type_)?
}

term_binder = _{
    term_lambda
    | term_erased_lambda
    | term_let
    | term_erased_let
    | term_rewrite
    | term_annotate
}

term_lambda_single_var = { bound_id ~ (":" ~ type_)? }
term_lambda_relevant_var = { bound_id ~ !":" | ("(" ~ bound_id ~ (":" ~ type_)? ~ ")") }
term_lambda_erased_var = { "-" ~ (bound_id | ("(" ~ bound_id ~ (":" ~ (kind | type_))? ~ ")")) }
term_lambda = { "λ" ~ ((term_lambda_relevant_var | term_lambda_erased_var)+ | term_lambda_single_var) ~ "." }
term_erased_lambda = { "Λ" ~ bound_id ~ (":" ~ (kind | type_))? ~ "." }
term_let = { "[" ~ (define_term | define_type) ~ "]" ~ "-" }
term_erased_let = { "{" ~ define_term ~ "}" ~ "-" }
term_rewrite = { "ρ" ~ reduce? ~ ("<" ~ num ~ ">")? ~ term_atom ~ guide? ~ "-" }
term_annotate = { "χ" ~ type_ ~ "-" }

term_atom = {
    term_intersection ~ proj*
    | term_refl
    | term_cast ~ proj*
    | term_induction ~ proj*
    | term_match ~ proj*
    | term_separate
    | term_symmetry
    | "(" ~ term ~ ")" ~ proj*
    | hole
    | omission
    | qual_id ~ proj*
}

term_intersection = { "[" ~ term ~ "," ~ term ~ "]" }
term_refl = { "β" ~ term_guide? ~ ("{" ~ term ~ "}")? }
term_cast = { "φ" ~ term_atom ~ "-" ~ term_application ~ "{" ~ term ~ "}" }
term_induction = { "μ" ~ id ~ "." ~ term_application ~ ("@" ~ type_)? ~ "{" ~ cases ~ "}" }
term_match = { ("σ" | mu_prime) ~ term_guide? ~ term_application ~ ("@" ~ type_)? ~ "{" ~ cases ~ "}" }
term_separate = { "δ" ~ type_? ~ "-" ~ term }
term_symmetry = { "ς" ~ term_atom }

type_ = { type_binder* ~ type_body }

type_body = { 
    type_atom
    ~ ((erased_arrow | arrow) ~ type_ | "·" ~ type_atom | term_atom)*
}

type_application = { type_atom ~ ("·" ~ type_atom | term_atom)* }

type_binder = _{
    type_forall
    | type_erased_forall
    | type_lambda
    | type_intersection
    | type_let
}

type_lambda_single_var = { bound_id ~ (":" ~ (kind | type_))? }
type_lambda_var = { bound_id ~ !":" | ("(" ~ bound_id ~ (":" ~ (kind | type_))? ~ ")") }
type_lambda = { "λ" ~ ((type_lambda_var+) | type_lambda_single_var) ~ "." }
type_forall = { "Π" ~ bound_id ~ ":" ~ type_ ~ "." }
type_erased_forall = { "∀" ~ bound_id ~ ":" ~ (kind | type_) ~ "." }
type_intersection = { "ι" ~ bound_id ~ ":" ~ type_ ~ "." }
type_let = { "[" ~ (define_term | define_type) ~ "]" ~ "-" }

type_atom = {
    "{" ~ term ~ "≃" ~ term ~ "}"
    | "(" ~ type_ ~ ")"
    | hole
    | omission
    | qual_id
}


kind = { 
    (kind_binder | type_application ~ "➔")*
    ~ kind_atom
    ~ ("➔" ~ kind)*
}

kind_binder = { "Π" ~ bound_id ~ ":" ~ (kind | type_) ~ "." }

kind_atom = { 
    "(" ~ kind ~ ")"
    | star
    | qual_kind_id ~ ("·" ~ type_atom | term_atom)+
}

kind_arg = { "(" ~ id ~ ":" ~ (kind | type_) ~ ")" }

guide = { "@" ~ id ~ term_guide? ~ "." ~ type_ }

ctors = { "|"? ~ ctor ~ ("|" ~ ctor)* }
ctor = { id ~ ":" ~ type_ }
cases = { "|"? ~ case ~ ("|" ~ case)* }
case = { qual_id ~ case_arg* ~ "➔" ~ term }
case_arg = ${ (type_op | erased_op)? ~ id }

import_argument = { "·" ~ type_ | erased_op? ~ term }
param = { relevant_param | erased_param }
relevant_param = { "(" ~ id ~ ":" ~ (kind | type_) ~ ")" }
erased_param = { "{" ~ id ~ ":" ~ type_ ~ "}" }

term_guide = { "<" ~ term ~ ">" }

bound_id = { id | omission }
id = @{ alpha ~ (alpha | greek | numeral | punctuation)* | "_" }
qual_id = ${ (id ~ ("."|"/") ~ &id)* ~ id  }

kind_id = @{ "𝒌" ~ (alpha | numeral | punctuation)* }
qual_kind_id = ${ (id ~ "." ~ &id)* ~ kind_id }

path = @{
    ("../")* ~ (alpha | numeral | punctuation | "/" )+
}

erased_arrow = @{ "➾" }
arrow = @{ "➔" }
erased_op = @{ "-" }
type_op = @{ "·" }
hole = @{ "●" }
omission = @{ "_" }
star = @{ "★" }
proj = @{ ".1" | ".2" }
reduce = @{ "+" }
public = @{ "public" }
mu_prime = @{ "μ'" }

alpha = @{ 'a'..'z' | 'A'..'Z' }
greek = @{ 'α'..'ω' | 'Α'..'Ω' }
numeral = @{ '0'..'9' }
punctuation = @{ "_" | "'" | "-" | "!" | "~" }

num = @{ '1'..'9' ~ '0'..'9'* }

multiline_comment = @{ "{-" ~ (!"-}" ~ ANY)* ~ "-}" }
suffix_comment = @{ "{-" ~ ANY* ~ EOI }
line_comment = @{ "--" ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI) }

WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT = _{ line_comment | multiline_comment | suffix_comment }
